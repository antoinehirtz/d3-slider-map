<!DOCTYPE html>
<html>

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title></title>
  <style>

    body{
      font-family: 'Lato',sans-serif;
    }

    p{
      font-size: 10pt;
    }
    .countries{
      stroke:#000;
    }
    .legend rect{
      stroke:#000;
    }
  </style>
</head>

<body>
  <h2>Number of deaths caused by disasters in 2000</h2>
  <p><input type="range" min="2000" max="2013" value="2000" id="year"></p>
  <svg width="960" height="425"></svg>
  <p>Slider adapted from <a href="http://www.d3noob.org/2014/04/using-html-inputs-with-d3js.html">D3 Noob</a></p>
  <p>Data source: <a href="http://unstats.un.org/sdgs/indicators/database/?indicator=11.5.1">UN Stats</a></p>

  <script src="http://d3js.org/d3.v4.min.js"></script>
  <script src="https://d3js.org/topojson.v2.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://d3js.org/d3-geo-projection.v1.min.js"></script>

  <script>

    // params
    var color_na = "#E7E7E7";
    // only works if array.length-1 is between 3 and 9 (d3 color scheme)
    var quantiles = [0, 0.2, 0.4, 0.6, 0.8, 1];

    // load data and store it globally
    var data = {};
    d3.json("data/data_sdgs-disaster_proc.json", function(error, d) {
      if (error) throw error;
      data = d;
    });

    // init map container & projection
    var svg = d3.select("svg"),
        width = svg.attr("width"),
        height = svg.attr("height");
    var path = d3.geoPath(d3.geoRobinson());

    // init legend container
    svg.append("g")
        .attr("class", "legend");
    d3.select("svg")
      .append("g")
        .attr("class", "legend_title")
      .append("text")
        .text("Legend (quintile ranges)")
        .attr("y", 290);

    // load map data and render it
    d3.json("data/world.json", function(error, worldmap) {
      if (error) throw error;

      // calculate color scale, calculate legend
      color = getColorScale(2000);
      drawLegend(color);

      // init map
      svg.append("g")
          .attr("class", "countries")
        .selectAll("path")
        .data(topojson.feature(worldmap, worldmap.objects.world).features)
        .enter().append("path")
          .attr("d", path)
          .attr("fill", function(d) { return (typeof data[2000][d.id] === 'undefined' ? color_na : color(data[2000][d.id])); })
          .attr("id", function(d) { return d.id; })
        .append("title")
          .text(function(d) { return "" + d.id + ", " + (typeof data[2000][d.id] === 'undefined' ? 'N/A' : data[2000][d.id]); });
    });

    // was the slider used?
    d3.select("#year").on("input", function() {
        updateMap(this.value);
    });

    function updateMap(year) {

        let data_year = data[year];

        // update scale and legend
        color = getColorScale(year);
        drawLegend(color);

        // update path fill attributes
        var fill = d3.selectAll("svg path").transition()
          .delay(500)
          .attr("fill", "#FFF")
          .attr("fill", function(d) { return (typeof data_year[d.id] === 'undefined' ? color_na : color(data_year[d.id])); });

        // update path titles
        d3.selectAll("svg path title")
          .text(function(d) { return "" + d.id + ", " + (typeof data_year[d.id] === 'undefined' ? 'N/A' : data_year[d.id]); });

        // update headline
        d3.select("h2").text("Number of deaths caused by disasters in " + year);
    }

    function getColorScale(year) {

      // get values, turn to int and sort
      let data_values = Object.values(data[year]).sort(function(a, b){return a-b});

      quantiles_calc = quantiles.map( function(elem) {
        return Math.ceil(d3.quantile(data_values, elem));
      });

      let scale = d3.scaleQuantile()
                .domain(quantiles_calc)
                .range(d3.schemeReds[(quantiles_calc.length)-1]);

      return scale;
    }

    function drawLegend(scale) {

      let legend = d3.select("svg g.legend");
      let svg_height = +d3.select("svg").attr("height");
      let legend_items = pairQuantiles(scale.domain());

      legend.selectAll("rect")
        .data(scale.range())
        .enter().append("rect")
            .attr("width", "20")
            .attr("height", "20")
            .attr("y", function(d, i) { return (svg_height-25) - 25*i; })
            .attr("fill", function(d, i) { return d; });

      let text = legend.selectAll("text");

      text.data(legend_items)
        .enter().append("text").merge(text)
          .attr("y", function(d, i) { return (svg_height-10) - 25*i; })
          .attr("x", 30)
          .text(function(d, i) { return d; });
    }

    // helper function, pairs neighboring elements in array
    function pairQuantiles(arr) {
      new_arr = [];
      for (let i=0; i<arr.length-1; i++) {

        // allow for closed intervals (depends on d3.scaleQuantile)
        // assumes that neighboring elements are equal
        if(i == arr.length-2) {
          new_arr.push(arr[i] + " - " +  arr[i+1]);
        }
        else {
          new_arr.push(arr[i] + " - " +  (arr[i+1]-1));
        }
      }
      return new_arr;
    }
  </script>
</body>
</html>
